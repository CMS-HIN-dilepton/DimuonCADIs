#ifndef __CINT__#endif#include "initOniaTree.C"#include "TLatex.h"#include "TCanvas.h"#include "TROOT.h"#include "TAxis.h"#include "TProfile.h"#include "TH1.h"#include "TTree.h"#include "TFile.h"#include "TH1D.h"#include "TH2D.h"#include "TF1.h"#include "TH1I.h"#include "TCanvas.h"#include "TLine.h"#include "TMath.h"#include "TVector3.h"#include "TString.h"#include "TLegend.h"#include "TChain.h"#include "TCut.h"#include "TLegendEntry.h"#include "TPaveStats.h"#include "RooGenericPdf.h"#include "RooRealVar.h"#include "RooDataSet.h"#include "RooAddPdf.h"#include "RooGaussian.h"#include "RooChebychev.h"#include "RooCBShape.h"#include "RooPlot.h"#include "RooMCStudy.h"#include "RooFitResult.h"#include "RooWorkspace.h"#include "RooKeysPdf.h"#include "RooStats/ModelConfig.h"#include "RooStats/ProfileLikelihoodCalculator.h"#include "RooStats/LikelihoodInterval.h"#include "RooStats/LikelihoodIntervalPlot.h"#include "RooRealVar.h"#include "RooDataSet.h"#include "RooGaussian.h"#include "RooFitResult.h"#include "RooLandau.h"#include "RooChebychev.h"#include "RooAddPdf.h"#include "RooPlot.h"#include "RooDataHist.h"#include "RooVoigtian.h"#include "RooCBShape.h"#include "RooArgusBG.h"#include "RooPolynomial.h"#include "RooExponential.h"#include "RooBinning.h"#include "RooHist.h"#include "TRandom.h"#include "TStyle.h"#include "TSystem.h"#include "TGraph.h"#include "TGraphErrors.h"#include <fstream>#include <map>#include <string>#include <iostream>#include <stdio.h>#include <string.h>#include <TObjArray.h>#include <TLorentzVector.h>#include <TClonesArray.h>#include "FitFunctions.h"#include "TSystemFile.h"#include "TSystemDirectory.h"#include "TList.h"#include "TString.h"#include "signal.h"bool IsAccept(Double_t pt, Double_t eta); //you can define acceptance here bool IspAaccept(Double_t Rap,Double_t eta1,Double_t eta2); //you can define acceptance here double findNcoll(int hiBin);double FindCenWeight(int Bin);void BhadronSyst_Loop(int loop);bool isplot =1;bool CB =0;bool CBG=1;Int_t loopStart =0;Int_t loopend =1;Double_t massMin=0.0,massMax=0.0;double BkgPDF = 6;double bfracFit();void BhadronSyst(){  for(int i=loopStart; i<loopend; i++){BhadronSyst_Loop(i);}}void BhadronSyst_Loop(int loop){  //double ymin=0,ymax=0,pmin=0,pmax=0;  double DRatio[20] = {0}, DRatioEr[20] = {0};   TH1::AddDirectory(kFALSE);  gStyle->SetCanvasDefH(600);  gStyle->SetCanvasDefW(600);    gROOT->SetStyle("Plain");  gStyle->SetPalette(1);  gStyle->SetFrameBorderMode(0);  gStyle->SetFrameFillColor(0);  gStyle->SetCanvasColor(0);  gStyle->SetTitleFillColor(0);  gStyle->SetStatColor(0);  gStyle->SetPadBorderSize(0);  gStyle->SetCanvasBorderSize(0);  gStyle->SetOptTitle(0); // at least most of the time  gStyle->SetOptStat("nemr"); // most of the time, sometimes "nemriou" might be useful to display name,   //number of entries, mean, rms, integral, overflow and underflow  gStyle->SetOptFit(1); // set to 1 only if you want to display fit results    //=================================== Histo for all cut variables ==========================================  using namespace RooFit;  using namespace RooStats;   void setWSRange(RooWorkspace *ws);  void defineMassBkg(RooWorkspace *ws);  void defineMassSig(RooWorkspace *ws);      double RError(double,double,double,double);  double WeightRatioError(double,double,double,double);    bool is3D =1;  bool significance = 0;  bool isHI=0;   bool savePlot=0;  bool Binning =0;  bool ctauFit = 0;  bool isForw = 0;   bool isMid = 1;    float ptmin=3.0; float ptmax=30.0; float ymin=1.6; float ymax=2.4; bool absRapidity=true;   double threshold=0.8; double efficiency=0.9; int centmin=0; int centmax=40;  if(isForw) {ymin=1.6; ymax=2.4; ptmin=3.0; ptmax=30.0;}  //ymin=1.6; ymax=2.4; ptmin=3.0; ptmax=6.5;   //ymin=1.6; ymax=2.4; ptmin=6.5; ptmax=12.0;   //ymin=1.6; ymax=2.4; ptmin=12.0; ptmax=30.0;     if(isMid) {ymin=0.0; ymax=1.6; ptmin=6.5; ptmax=30.0; }  //ymin=0.0; ymax=1.6; ptmin=6.5; ptmax=9.0;    //ymin=0.0; ymax=1.6; ptmin=9.0; ptmax=12.0;    //ymin=0.0; ymax=1.6; ptmin=12.0; ptmax=15.0;    //ymin=0.0; ymax=1.6; ptmin=15.0; ptmax=20.0;    //ymin=0.0; ymax=1.6; ptmin=20.0; ptmax=30.0;      int range1 = 0; int fbin = 0;  int range2 = 0; int lbin = 0;  float xVal = 0.0;  if(significance){    range1 = -10;    range2 = 50;    fbin = -10; lbin = 50;    xVal = 11.0;  }else{    range1 = -1;    range2 = 3;    fbin = -5; lbin = 10;    xVal = 0.5;  }  float lCut=-10.0;  TLegend *leg = new TLegend(0.38,0.52,0.9,0.78);  if (isHI)    leg->SetHeader("PYTHIA: PbPb #sqrt{s_{NN}} = 5.02 TeV");  else    leg->SetHeader("PYTHIA: pp #sqrt{s} = 5.02 TeV");  leg->SetFillStyle(0);  leg->SetFillColor(0);  leg->SetBorderSize(0);  leg->SetMargin(0.15);  leg->SetTextSize(0.032);  leg->SetTextColor(2);  TCut defaultCut = NULL;  //  TCut defaultCut = "Reco_QQ_sign==0&&Gen_QQ_4mom.M()>3.09&&Gen_QQ_4mom.M()<3.10&&Reco_QQ_4mom.M()>2.9&&Reco_QQ_4mom.M()<3.2&&Reco_QQ_ctauTrue>-10";  defaultCut = "Reco_QQ_sign==0&&Reco_QQ_4mom.M()>2.9&&Reco_QQ_4mom.M()<3.2&&Reco_QQ_ctau>-500&&Reco_QQ_ctauTrue>-10";  if(significance)    defaultCut = "Reco_QQ_sign==0&&Reco_QQ_4mom.M()>2.85&&Reco_QQ_4mom.M()<3.25&&Reco_QQ_ctau>-500&&Reco_QQ_ctauErr>-500&&Reco_QQ_ctauTrue>-10";  if(is3D){    defaultCut = "Reco_QQ_sign==0&&Reco_QQ_4mom.M()>2.85&&Reco_QQ_4mom.M()<3.25&&Reco_QQ_ctau3D>-500&&Reco_QQ_ctauTrue3D>-10";    if(significance)      defaultCut = "Reco_QQ_sign==0&&Reco_QQ_4mom.M()>2.85&&Reco_QQ_4mom.M()<3.25&&Reco_QQ_ctau3D>-500&&Reco_QQ_ctauErr3D>-500&&Reco_QQ_ctauTrue3D>-10";  }    TCut ptCut = Form("Reco_QQ_4mom.Pt()>%3.1f&&Reco_QQ_4mom.Pt()<%3.1f",ptmin,ptmax);  TCut rapCut;  if (absRapidity)    rapCut = Form("abs(Reco_QQ_4mom.Rapidity())>%3.1f&&abs(Reco_QQ_4mom.Rapidity())<%3.1f",ymin,ymax);  else    rapCut = Form("Reco_QQ_4mom.Rapidity()>%3.1f&&Reco_QQ_4mom.Rapidity()<%3.1f",ymin,ymax);  TCut centCut;  if (isHI)    centCut = Form("Centrality>=%d&&Centrality<%d",centmin,centmax);    // new Acceptance  TCut IsPlAccept = "(abs(Reco_QQ_mupl_4mom->Eta()) < 2.4 && ( (abs(Reco_QQ_mupl_4mom->Eta()) < 1.2 && Reco_QQ_mupl_4mom->Pt() >= 3.5 ) || (1.2 <= abs(Reco_QQ_mupl_4mom->Eta()) && abs(Reco_QQ_mupl_4mom->Eta()) < 2.1 && Reco_QQ_mupl_4mom->Pt() >= 5.77-1.89*abs(Reco_QQ_mupl_4mom->Eta() )) || (2.1 <= abs(Reco_QQ_mupl_4mom->Eta()) && Reco_QQ_mupl_4mom->Pt() >= 1.8 )))";  TCut IsMiAccept = "(abs(Reco_QQ_mumi_4mom->Eta()) < 2.4 && ( (abs(Reco_QQ_mumi_4mom->Eta()) < 1.2 && Reco_QQ_mumi_4mom->Pt() >= 3.5 ) || (1.2 <= abs(Reco_QQ_mumi_4mom->Eta()) && abs(Reco_QQ_mumi_4mom->Eta()) < 2.1 && Reco_QQ_mumi_4mom->Pt() >= 5.77-1.89*abs(Reco_QQ_mumi_4mom->Eta() )) || (2.1 <= abs(Reco_QQ_mumi_4mom->Eta()) && Reco_QQ_mumi_4mom->Pt() >= 1.8 )))";  TCut MuPlID = "((Reco_QQ_mupl_isGoodMuon==1) && Reco_QQ_mupl_nTrkWMea> 5 &&  Reco_QQ_mupl_nPixWMea > 0 && TMath::Abs(Reco_QQ_mupl_dxy) < 0.3 && TMath::Abs(Reco_QQ_mupl_dz) < 20 && Reco_QQ_VtxProb > 0.01 )";  TCut MuMiID = "((Reco_QQ_mumi_isGoodMuon==1) && Reco_QQ_mumi_nTrkWMea> 5 &&  Reco_QQ_mumi_nPixWMea > 0 && TMath::Abs(Reco_QQ_mumi_dxy) < 0.3 && TMath::Abs(Reco_QQ_mumi_dz) < 20 && Reco_QQ_VtxProb > 0.01 )";      unsigned int trigBit;  if (isHI)    trigBit=1; // DoubleMu0_HighQ  else    trigBit=1; // DoubleMu0_HighQ  TCut trigCut = Form("(HLTriggers&%u)==%u&&(Reco_QQ_trig&%u)==%u",trigBit,trigBit,trigBit,trigBit);  TString fname;  TString fnamepng;  TString outfname;  TString plotDir;    if(!is3D){plotDir = "Plots/2015";}  if(!is3D && significance){plotDir = "Plots/2015/significance";}  if(is3D){plotDir = "Plots/2015/3D";}  if(is3D && Binning){plotDir = "Plots/2015/3D/Binning";}  if(is3D && ctauFit){plotDir = "Plots/2015/3D/ctauFit";}  if(is3D && significance){plotDir = "Plots/2015/3D/significance";}    if (isHI) {    //    fname = "PbPb_eff_" + efficiency + "_Rap_" + ymin + "-" + ymax + "_Pt_" + ptmin + "-" + ptmax + ".pdf";    fname = Form("/Jpsi_PbPb_eff_%3.1f_Rap_%3.1f-%3.1f_Pt_%3.1f-%3.1f_Cent_%d-%d.pdf",efficiency,ymin,ymax,ptmin,ptmax,int(centmin/2.0),int(centmax/2.0));    fnamepng = Form("/Jpsi_PbPb_eff_%3.1f_Rap_%3.1f-%3.1f_Pt_%3.1f-%3.1f_Cent_%d-%d.png",efficiency,ymin,ymax,ptmin,ptmax,int(centmin/2.0),int(centmax/2.0));    outfname = Form("/Jpsi_PbPb_eff_%3.1f_Rap_%3.1f-%3.1f_Pt_%3.1f-%3.1f_Cent_%d-%d.root",efficiency,ymin,ymax,ptmin,ptmax,int(centmin/2.0),int(centmax/2.0));  }   else {    fname = Form("/Jpsi_pp_eff_%3.1f_Rap_%3.1f-%3.1f_Pt_%3.1f-%3.1f.pdf",efficiency,ymin,ymax,ptmin,ptmax);    fnamepng = Form("/Jpsi_pp_eff_%3.1f_Rap_%3.1f-%3.1f_Pt_%3.1f-%3.1f.png",efficiency,ymin,ymax,ptmin,ptmax);    outfname = Form("/Jpsi_pp_eff_%3.1f_Rap_%3.1f-%3.1f_Pt_%3.1f-%3.1f.root",efficiency,ymin,ymax,ptmin,ptmax);  }  std::cout << fname << std::endl;  std::cout << "default: " << defaultCut.GetTitle() << std::endl;  std::cout << "pt cut: " << ptCut.GetTitle() << std::endl;  std::cout << "rapidity cut: " << rapCut.GetTitle() << std::endl;  std::cout << "centrality cut: " << centCut.GetTitle() << std::endl;  std::cout << "trigger bit: " << trigCut.GetTitle() << std::endl;  TLatex *lpt;  if (ptmin==0.0)    lpt = new TLatex(0.38,0.82,Form("p_{T} < %3.1f GeV/c",ptmax));  else{    lpt = new TLatex(0.38,0.82,Form("%3.1f < p_{T} < %3.1f GeV/c",ptmin,ptmax));    lpt->SetTextSize(0.033);  }  TLatex *lrap;  if (absRapidity){    if (ymin==0.0){      lrap = new TLatex(0.38,0.77,Form("|y| < %3.1f",ymax));      lrap->SetTextSize(0.033);    }    else{      lrap = new TLatex(0.38,0.77,Form("%3.1f < |y| < %3.1f",ymin,ymax));      lrap->SetTextSize(0.033);    }  }  else {    if (ymin==0.0)      lrap = new TLatex(0.38,0.77,Form("y < %3.1f",ymax));    else      lrap = new TLatex(0.38,0.77,Form("%3.1f < y < %3.1f",ymin,ymax));  }  lpt->SetNDC(kTRUE);  lrap->SetNDC(kTRUE);    TLatex *lcent = NULL;  if (isHI) {    lcent = new TLatex(0.38,0.71,Form("Cent. %d-%d%%",int(centmin/2.0),int(centmax/2.0)));    lcent->SetTextSize(0.033);    lcent->SetNDC(kTRUE);  }    TChain *PRTree = NULL;  if (isHI) {    PRTree = new TChain("hionia/myTree");    PRTree->Add("/home/abdulla/CMS/quarkoniaData/Charm2015/rootfiles/MC/PbPb/Jpsi/OniaTree_Pythia8_JpsiMM_ptJpsi_00_03_Hydjet_MB_HINPbPbWinter16DR-75X_mcRun2_HeavyIon_v13-v1.root");    PRTree->Add("/home/abdulla/CMS/quarkoniaData/Charm2015/rootfiles/MC/PbPb/Jpsi/OniaTree_Pythia8_JpsiMM_ptJpsi_03_06_Hydjet_MB_HINPbPbWinter16DR-75X_mcRun2_HeavyIon_v13-v1.root");    PRTree->Add("/home/abdulla/CMS/quarkoniaData/Charm2015/rootfiles/MC/PbPb/Jpsi/OniaTree_Pythia8_JpsiMM_ptJpsi_06_09_Hydjet_MB_HINPbPbWinter16DR-75X_mcRun2_HeavyIon_v13-v1.root");    PRTree->Add("/home/abdulla/CMS/quarkoniaData/Charm2015/rootfiles/MC/PbPb/Jpsi/OniaTree_Pythia8_JpsiMM_ptJpsi_09_12_Hydjet_MB_HINPbPbWinter16DR-75X_mcRun2_HeavyIon_v13-v1.root");    PRTree->Add("/home/abdulla/CMS/quarkoniaData/Charm2015/rootfiles/MC/PbPb/Jpsi/OniaTree_Pythia8_JpsiMM_ptJpsi_12_15_Hydjet_MB_HINPbPbWinter16DR-75X_mcRun2_HeavyIon_v13-v1.root");    PRTree->Add("/home/abdulla/CMS/quarkoniaData/Charm2015/rootfiles/MC/PbPb/Jpsi/OniaTree_Pythia8_JpsiMM_ptJpsi_15_30_Hydjet_MB_HINPbPbWinter16DR-75X_mcRun2_HeavyIon_v13-v1.root");    PRTree->Add("/home/abdulla/CMS/quarkoniaData/Charm2015/rootfiles/MC/PbPb/Jpsi/OniaTree_Pythia8_JpsiMM_ptJpsi_30_Inf_Hydjet_MB_HINPbPbWinter16DR-75X_mcRun2_HeavyIon_v13-v1.root");  }  else{    PRTree = new TChain("hionia/myTree");    PRTree->Add("/home/abdulla/CMS/quarkoniaData/Charm2015/rootfiles/MC/pp/OniaTree_JpsiMM_5p02TeV_TuneCUETP8M1_HINppWinter16DR-75X_mcRun2_asymptotic_ppAt5TeV_v3-v1.root");  }    Float_t         muPlPt;  Float_t         muMiPt;  Float_t         muPlEta;  Float_t         muMiEta;  Float_t         QQctau3D;  Float_t         QQctau3DErr;    double invariantMass;  double JpsiPt;  double JpsiRap;  double vProb;  float muPlDxy;  float muPlDz;  int muPlNhits;  int muPlNPxlLayers;  int muPlNTrkLayers;  float muPlInnerChi;  float muPlGlobalChi;  int muPlNMuonhits;  bool muPlGoodMu;  bool muPlTrkArb;  bool muPlTMOneStaTight;  bool muPlHighPurity;  float muMiDxy;  float muMiDz;  int muMiNhits;  int muMiNPxlLayers;  int muMiNTrkLayers;  float muMiInnerChi;  float muMiGlobalChi;  int muMiNMuonhits;  bool muMiGoodMu;  bool muMiTrkArb;  bool muMiTMOneStaTight;  bool muMiHighPurity;  TH1F *hPR = new TH1F("hPR","hPR;l_{J/#psi} (mm);counts",1500,-5,10);  hPR->Sumw2();  hPR->SetLineColor(1);  TH1F* hPRCut = (TH1F*) hPR->Clone("hPRCut");  TH1D *DiMuPt = new TH1D("DiMuPt", "DiMuPt", 160, 0, 40);  DiMuPt->GetXaxis()->SetTitle("p_{T}");  DiMuPt->Sumw2();  DiMuPt->SetMarkerColor(kGreen+3);  DiMuPt->SetMarkerStyle(20);  TH1D *DiMuPt2 = new TH1D("DiMuPt2", "DiMuPt2", 160, 0, 40);  DiMuPt2->GetXaxis()->SetTitle("p_{T}");  DiMuPt2->Sumw2();  DiMuPt2->SetMarkerColor(kRed+3);  DiMuPt2->SetMarkerStyle(20);  TH1D*Bfractn  = (TH1D*) DiMuPt2->Clone("Bfractn");    double bfracWt =0.0;    //bfracFit();  //return;    initOniaTree(PRTree);  Long64_t nentries = PRTree->GetEntries();  //nentries = 50000;            cout<<"Total Entries in data  Tree  "<<"  "<<nentries<< "====="<<endl;  Long64_t nbytes = 0, nb = 0;   for (Long64_t jentry=0; jentry<nentries;jentry++) {    nb = PRTree->GetEntry(jentry);           for (int iQQ=0; iQQ<Reco_QQ_size; iQQ++) {      TLorentzVector *qq4mom = (TLorentzVector*) Reco_QQ_4mom->At(iQQ);      TLorentzVector *qq4mupl = (TLorentzVector*) Reco_QQ_mupl_4mom->At(iQQ);      TLorentzVector *qq4mumi = (TLorentzVector*) Reco_QQ_mumi_4mom->At(iQQ);            invariantMass = qq4mom->M();      JpsiPt = qq4mom->Pt();      JpsiRap = qq4mom->Rapidity();      muPlPt = qq4mupl->Pt();      muMiPt = qq4mumi->Pt();      muPlEta = qq4mupl->Eta();      muMiEta = qq4mumi->Eta();      QQctau3D = Reco_QQ_ctau3D[iQQ];      //QQctauTrue3D = Reco_QQ_ctauTrue3D[iQQ];      vProb = Reco_QQ_VtxProb[iQQ];      muPlDxy=Reco_QQ_mupl_dxy[iQQ];      muPlDz=Reco_QQ_mupl_dz[iQQ];      muPlNPxlLayers=Reco_QQ_mupl_nPixWMea[iQQ];      muPlNTrkLayers=Reco_QQ_mupl_nTrkWMea[iQQ];      muPlTMOneStaTight=Reco_QQ_mupl_TMOneStaTight[iQQ];      muPlGoodMu = Reco_QQ_mupl_isGoodMuon[iQQ];      muPlHighPurity = Reco_QQ_mupl_highPurity[iQQ];      muMiDxy=Reco_QQ_mumi_dxy[iQQ];      muMiDz=Reco_QQ_mumi_dz[iQQ];      muMiNPxlLayers=Reco_QQ_mumi_nPixWMea[iQQ];      muMiNTrkLayers=Reco_QQ_mumi_nTrkWMea[iQQ];      muMiTMOneStaTight=Reco_QQ_mumi_TMOneStaTight[iQQ];      muMiGoodMu = Reco_QQ_mumi_isGoodMuon[iQQ];      muMiHighPurity = Reco_QQ_mumi_highPurity[iQQ];      bool defaultpass =0, ptpass =0, rappass =0, PosPass=0, NegPass=0, AllCut=0 ,PosIn=0, NegIn=0,TriggerPass=0, centCut=0;            if(Reco_QQ_sign[iQQ]==0 && invariantMass>2.85 && invariantMass<3.25 && Reco_QQ_ctau3D[iQQ]>-500 && Reco_QQ_ctauTrue3D[iQQ]>-10) {defaultpass =1;}      if(!defaultpass) continue;            if(JpsiPt>ptmin && JpsiPt<ptmax)  {ptpass =1;}      if( fabs(JpsiRap)>ymin && fabs(JpsiRap) <ymax )   {rappass =1;}      if(Centrality>= centmin&& Centrality< centmax) {centCut =1;}      if(!ptpass) continue;      if(!rappass) continue;       if(!centCut) continue;             if( (HLTriggers&(ULong64_t)pow(2,0))==pow(2,0) && (Reco_QQ_trig[iQQ]&(ULong64_t)pow(2,0))==pow(2,0) )	{TriggerPass =1;}            if (fabs(muPlEta) < 2.4 && ( (fabs(muPlEta) < 1.2 && muPlPt >= 3.5 ) || (1.2 <= fabs(muPlEta) && fabs(muPlEta) < 2.1 && muPlPt >= 5.77-1.89*fabs(muPlEta )) || (2.1 <= fabs(muPlEta) && muPlPt >= 1.8 )) )  {PosIn =1;}	      if(fabs(muMiEta) < 2.4 && ( (fabs(muMiEta) < 1.2 && muMiPt >= 3.5 ) || (1.2 <= fabs(muMiEta) && fabs(muMiEta) < 2.1 && muMiPt >= 5.77-1.89*fabs(muMiEta )) || (2.1 <= fabs(muMiEta) && muMiPt >= 1.8 )) )  {NegIn =1;}      if( (muPlGoodMu==1) && muPlNTrkLayers> 5 &&  muPlNPxlLayers > 0 && TMath::Abs(muPlDxy) < 0.3 && TMath::Abs(muPlDz) < 20 && vProb > 0.01){PosPass=1;}      if( (muMiGoodMu==1) && muMiNTrkLayers> 5 &&  muMiNPxlLayers > 0 && TMath::Abs(muMiDxy) < 0.3 && TMath::Abs(muMiDz) < 20 ){NegPass=1;}      //if((Reco_QQ_mupl_isGoodMuon==1) && Reco_QQ_mupl_nTrkWMea> 5 &&  Reco_QQ_mupl_nPixWMea > 0 && TMath::fabs(Reco_QQ_mupl_dxy) < 0.3 && TMath::fabs(Reco_QQ_mupl_dz) < 20 && Reco_QQ_VtxProb > 0.01 )  {PosPass =1;}      //if((Reco_QQ_mumi_isGoodMuon==1) && Reco_QQ_mumi_nTrkWMea> 5 &&  Reco_QQ_mumi_nPixWMea > 0 && TMath::fabs(Reco_QQ_mumi_dxy) < 0.3 && TMath::fabs(Reco_QQ_mumi_dz) < 20 && Reco_QQ_VtxProb > 0.01 )  {NegPass =1;}            if(TriggerPass &&PosIn && NegIn && PosPass && NegPass) {AllCut = 1;}      if(!AllCut) continue;            //bfracWt = 0.0229336*JpsiPt + 0.0776218;      bfracWt = 0.00898639 + 0.0334903*JpsiPt - 0.000599195*JpsiPt*JpsiPt;      DiMuPt->Fill(JpsiPt);      DiMuPt2->Fill(JpsiPt, bfracWt);            //hPR2D->Fill(JpsiPt,QQctau3D);    }  }    new TCanvas;  gPad->SetTickx();  gPad->SetTicky();  //gPad->SetLogy(1);  DiMuPt->Draw();  new TCanvas;  gPad->SetTickx();  gPad->SetTicky();  //gPad->SetLogy(1);  DiMuPt2->Draw();    for (int i=1;i<=DiMuPt2->GetNbinsX();++i) {    cout<<"i "<<i<<" "<<DiMuPt->GetBinContent(i)<<endl;    cout<<"i "<<i<<" "<<DiMuPt2->GetBinContent(i)<<endl;  }  double bfrac[20] = {0.0};  int binlow,binlow2;  int binhi,binhi2;  double pt_bound[100] = {0};    int Nptbin = 1;  if(isForw){    Nptbin = 5;    pt_bound[0] = 3.0;    pt_bound[1] = 6.5;    pt_bound[2] = 12.0;    pt_bound[3] = 30.0;    pt_bound[4] = 3.0;    pt_bound[5] = 30.0;  }  if(isMid){    Nptbin = 7;    pt_bound[0] = 6.5;    pt_bound[1] = 9.0;    pt_bound[2] = 12.0;    pt_bound[3] = 15.0;    pt_bound[4] = 20.0;    pt_bound[5] = 30.0;    pt_bound[6] = 6.5;    pt_bound[7] = 30.0;  }     for(int i=0; i<Nptbin; i++) {    if( (isForw && Nptbin==3) || (isMid && Nptbin==5))  continue;    binlow =DiMuPt->GetXaxis()->FindBin(pt_bound[i]);    binhi = DiMuPt->GetXaxis()->FindBin(pt_bound[i+1]);        binlow2 =DiMuPt2->GetXaxis()->FindBin(pt_bound[i]);    binhi2 = DiMuPt2->GetXaxis()->FindBin(pt_bound[i+1]);      bfrac[i] = DiMuPt2->Integral(binlow2,binhi2)/DiMuPt->Integral(binlow,binhi);    cout<<"bfrac : "<<bfrac[i]<<endl;  }    double CENT[100];  for(int ih=0; ih<Nptbin; ih++) {    if( (isForw && Nptbin==3) || (isMid && Nptbin==5))  continue;    CENT[ih]=((pt_bound[ih] + pt_bound[ih+1])/2.0);  }    TCanvas *Fitcanvas = new TCanvas("c","c",750, 550);  TGraph *bFracFW_pT = new TGraph(Nptbin,CENT,bfrac);  bFracFW_pT->SetLineColor(2);      bFracFW_pT->SetLineWidth(3);   bFracFW_pT->SetMarkerSize(1.35);  bFracFW_pT->SetMarkerStyle(20);  bFracFW_pT->SetMarkerColor(kGreen+3);  bFracFW_pT->GetYaxis()->SetTitle("f_{b}");  bFracFW_pT->GetXaxis()->SetTitle("p_{T}");    TAxis *XaxctauFW = bFracFW_pT->GetXaxis();  XaxctauFW->SetLimits(0.0,30.0);  TAxis *YaxctauFW = bFracFW_pT->GetYaxis();  YaxctauFW->SetLimits(0.0,1.0);  bFracFW_pT->GetXaxis()->SetRangeUser(0.0,30.0);  bFracFW_pT->GetYaxis()->SetRangeUser(0.0,1.0);  bFracFW_pT->Draw("AP");   lpt->Draw();  lrap->Draw();  leg->Draw();    if (isHI)    lcent->Draw();  return;}double bfracFit(){  // Table 24 from http://hepdata.cedar.ac.uk/view/irn9258752/next  // CMS pp at 7 TeV http://inspirehep.net/record/944755/plots  double ptBins[12] = {6.75, 7.125,7.375,7.75,8.25,8.75,9.5,10.5,11.5,13.5,22.5}; //19  double bfrac[12] = {0.199,0.225,0.239,0.233,0.237,0.25,0.258,0.299,0.321,0.356,0.458};  TCanvas *Fitcanvas = new TCanvas("c","c",750, 550);  TGraph *bFrac_pT = new TGraph(11,ptBins,bfrac);    TF1 *FitFn = new TF1("FitFn",Pol2,0.0,30.0,3);  //FitFn->SetParNames("C","a");  FitFn->SetParNames("C","a","b");  FitFn->SetLineWidth(2.0);  FitFn->SetLineColor(2);  bFrac_pT->Fit("FitFn","", "",3.0,30.0);  bFrac_pT->SetLineColor(2);      bFrac_pT->SetLineWidth(2);   bFrac_pT->SetMarkerSize(1.35);  bFrac_pT->SetMarkerStyle(20);  bFrac_pT->SetMarkerColor(kGreen+3);  bFrac_pT->GetYaxis()->SetTitle("f_{b}");  bFrac_pT->GetXaxis()->SetTitle("p_{T}");    TAxis *XaxctauFW = bFrac_pT->GetXaxis();  XaxctauFW->SetLimits(0.0,30.0);  TAxis *YaxctauFW = bFrac_pT->GetYaxis();  YaxctauFW->SetLimits(0.0,1.0);  bFrac_pT->GetXaxis()->SetRangeUser(0.0,30.0);  bFrac_pT->GetYaxis()->SetRangeUser(0.0,1.0);  bFrac_pT->Draw("AP");  return 0;  /*new TCanvas;  TAxis *XaxctauFW = FitGr->GetXaxis();  XaxctauFW->SetLimits(0.0,30.0);  TAxis *YaxctauFW = FitGr->GetYaxis();  YaxctauFW->SetLimits(0.0,0.1);  FitGr->GetXaxis()->SetRangeUser(0.0,30.0);  FitGr->GetYaxis()->SetRangeUser(0.0,0.1);  //FitGr->Draw("AP");  //FitGr->Draw();  func1->Draw();*/}