#ifndef __CINT__#endif#include "initOniaTree.C"#include "TLatex.h"#include "TCanvas.h"#include "TROOT.h"#include "TAxis.h"#include "TProfile.h"#include "TH1.h"#include "TTree.h"#include "TFile.h"#include "TH1D.h"#include "TH2D.h"#include "TF1.h"#include "TH1I.h"#include "TCanvas.h"#include "TLine.h"#include "TMath.h"#include "TVector3.h"#include "TString.h"#include "TLegend.h"#include "TChain.h"#include "TCut.h"#include "TLegendEntry.h"#include "TPaveStats.h"#include "RooGenericPdf.h"#include "RooRealVar.h"#include "RooDataSet.h"#include "RooAddPdf.h"#include "RooGaussian.h"#include "RooChebychev.h"#include "RooCBShape.h"#include "RooPlot.h"#include "RooMCStudy.h"#include "RooFitResult.h"#include "RooWorkspace.h"#include "RooKeysPdf.h"#include "RooStats/ModelConfig.h"#include "RooStats/ProfileLikelihoodCalculator.h"#include "RooStats/LikelihoodInterval.h"#include "RooStats/LikelihoodIntervalPlot.h"#include "RooRealVar.h"#include "RooDataSet.h"#include "RooGaussian.h"#include "RooFitResult.h"#include "RooLandau.h"#include "RooChebychev.h"#include "RooAddPdf.h"#include "RooPlot.h"#include "RooDataHist.h"#include "RooVoigtian.h"#include "RooCBShape.h"#include "RooArgusBG.h"#include "RooPolynomial.h"#include "RooExponential.h"#include "RooBinning.h"#include "RooHist.h"#include "TRandom.h"#include "TStyle.h"#include "TSystem.h"#include "TGraph.h"#include "TGraphErrors.h"#include <fstream>#include <map>#include <string>#include <iostream>#include <stdio.h>#include <string.h>#include <TObjArray.h>#include <TLorentzVector.h>#include <TClonesArray.h>#include "FitFunctions.h"#include "TSystemFile.h"#include "TSystemDirectory.h"#include "TList.h"#include "TString.h"#include "signal.h"bool IsAccept(Double_t pt, Double_t eta); //you can define acceptance here bool IspAaccept(Double_t Rap,Double_t eta1,Double_t eta2); //you can define acceptance here double findNcoll(int hiBin);double FindCenWeight(int Bin);void lJpsiTunefit2015_Loop(int loop);bool isplot =1;bool CB =0;bool CBG=1;Int_t loopStart =0;Int_t loopend =1;Double_t massMin=0.0,massMax=0.0;double BkgPDF = 6;void lJpsiTunefit2015(){  for(int i=loopStart; i<loopend; i++){lJpsiTunefit2015_Loop(i);}}void lJpsiTunefit2015_Loop(int loop){  //double ymin=0,ymax=0,pmin=0,pmax=0;  double DRatio[20] = {0}, DRatioEr[20] = {0};   TH1::AddDirectory(kFALSE);  gStyle->SetCanvasDefH(600);  gStyle->SetCanvasDefW(600);    gROOT->SetStyle("Plain");  gStyle->SetPalette(1);  gStyle->SetFrameBorderMode(0);  gStyle->SetFrameFillColor(0);  gStyle->SetCanvasColor(0);  gStyle->SetTitleFillColor(0);  gStyle->SetStatColor(0);  gStyle->SetPadBorderSize(0);  gStyle->SetCanvasBorderSize(0);  gStyle->SetOptTitle(0); // at least most of the time  gStyle->SetOptStat("nemr"); // most of the time, sometimes "nemriou" might be useful to display name,   //number of entries, mean, rms, integral, overflow and underflow  gStyle->SetOptFit(1); // set to 1 only if you want to display fit results    //=================================== Histo for all cut variables ==========================================  using namespace RooFit;  using namespace RooStats;   void setWSRange(RooWorkspace *ws);  void defineMassBkg(RooWorkspace *ws);  void defineMassSig(RooWorkspace *ws);      double RError(double,double,double,double);  double WeightRatioError(double,double,double,double);    bool is3D =1;  bool significance = 0;  bool isHI=1;   bool savePlot=0;  bool Binning =0;  bool ctauFit = 1;    float ptmin=3.0; float ptmax=30.0; float ymin=1.6; float ymax=2.4; bool absRapidity=true;   double threshold=0.8; double efficiency=0.9; int centmin=0; int centmax=40;  ymin=1.6; ymax=2.4; ptmin=3.0; ptmax=30.0;   //ymin=1.6; ymax=2.4; ptmin=3.0; ptmax=6.5;   //ymin=1.6; ymax=2.4; ptmin=6.5; ptmax=12.0;   //ymin=1.6; ymax=2.4; ptmin=12.0; ptmax=30.0;     //ymin=0.0; ymax=1.6; ptmin=6.5; ptmax=30.0;    //ymin=0.0; ymax=1.6; ptmin=6.5; ptmax=9.0;    //ymin=0.0; ymax=1.6; ptmin=9.0; ptmax=12.0;    //ymin=0.0; ymax=1.6; ptmin=12.0; ptmax=15.0;    //ymin=0.0; ymax=1.6; ptmin=15.0; ptmax=20.0;    //ymin=0.0; ymax=1.6; ptmin=20.0; ptmax=30.0;      int range1 = 0; int fbin = 0;  int range2 = 0; int lbin = 0;  float xVal = 0.0;  if(significance){    range1 = -10;    range2 = 50;    fbin = -10; lbin = 50;    xVal = 11.0;  }else{    range1 = -1;    range2 = 3;    fbin = -5; lbin = 10;    xVal = 0.5;  }  float lCut=-10.0;  TLegend *leg = new TLegend(0.38,0.52,0.9,0.78);  if (isHI)    leg->SetHeader("PYTHIA: PbPb #sqrt{s_{NN}} = 5.02 TeV");  else    leg->SetHeader("PYTHIA: pp #sqrt{s} = 5.02 TeV");  leg->SetFillStyle(0);  leg->SetFillColor(0);  leg->SetBorderSize(0);  leg->SetMargin(0.15);  leg->SetTextSize(0.032);  leg->SetTextColor(2);  TCut defaultCut = NULL;  //  TCut defaultCut = "Reco_QQ_sign==0&&Gen_QQ_4mom.M()>3.09&&Gen_QQ_4mom.M()<3.10&&Reco_QQ_4mom.M()>2.9&&Reco_QQ_4mom.M()<3.2&&Reco_QQ_ctauTrue>-10";  defaultCut = "Reco_QQ_sign==0&&Reco_QQ_4mom.M()>2.9&&Reco_QQ_4mom.M()<3.2&&Reco_QQ_ctau>-500&&Reco_QQ_ctauTrue>-10";  if(significance)    defaultCut = "Reco_QQ_sign==0&&Reco_QQ_4mom.M()>2.85&&Reco_QQ_4mom.M()<3.25&&Reco_QQ_ctau>-500&&Reco_QQ_ctauErr>-500&&Reco_QQ_ctauTrue>-10";  if(is3D){    defaultCut = "Reco_QQ_sign==0&&Reco_QQ_4mom.M()>2.85&&Reco_QQ_4mom.M()<3.25&&Reco_QQ_ctau3D>-500&&Reco_QQ_ctauTrue3D>-10";    if(significance)      defaultCut = "Reco_QQ_sign==0&&Reco_QQ_4mom.M()>2.85&&Reco_QQ_4mom.M()<3.25&&Reco_QQ_ctau3D>-500&&Reco_QQ_ctauErr3D>-500&&Reco_QQ_ctauTrue3D>-10";  }    TCut ptCut = Form("Reco_QQ_4mom.Pt()>%3.1f&&Reco_QQ_4mom.Pt()<%3.1f",ptmin,ptmax);  TCut rapCut;  if (absRapidity)    rapCut = Form("abs(Reco_QQ_4mom.Rapidity())>%3.1f&&abs(Reco_QQ_4mom.Rapidity())<%3.1f",ymin,ymax);  else    rapCut = Form("Reco_QQ_4mom.Rapidity()>%3.1f&&Reco_QQ_4mom.Rapidity()<%3.1f",ymin,ymax);  TCut centCut;  if (isHI)    centCut = Form("Centrality>=%d&&Centrality<%d",centmin,centmax);    // new Acceptance  TCut IsPlAccept = "(abs(Reco_QQ_mupl_4mom->Eta()) < 2.4 && ( (abs(Reco_QQ_mupl_4mom->Eta()) < 1.2 && Reco_QQ_mupl_4mom->Pt() >= 3.5 ) || (1.2 <= abs(Reco_QQ_mupl_4mom->Eta()) && abs(Reco_QQ_mupl_4mom->Eta()) < 2.1 && Reco_QQ_mupl_4mom->Pt() >= 5.77-1.89*abs(Reco_QQ_mupl_4mom->Eta() )) || (2.1 <= abs(Reco_QQ_mupl_4mom->Eta()) && Reco_QQ_mupl_4mom->Pt() >= 1.8 )))";  TCut IsMiAccept = "(abs(Reco_QQ_mumi_4mom->Eta()) < 2.4 && ( (abs(Reco_QQ_mumi_4mom->Eta()) < 1.2 && Reco_QQ_mumi_4mom->Pt() >= 3.5 ) || (1.2 <= abs(Reco_QQ_mumi_4mom->Eta()) && abs(Reco_QQ_mumi_4mom->Eta()) < 2.1 && Reco_QQ_mumi_4mom->Pt() >= 5.77-1.89*abs(Reco_QQ_mumi_4mom->Eta() )) || (2.1 <= abs(Reco_QQ_mumi_4mom->Eta()) && Reco_QQ_mumi_4mom->Pt() >= 1.8 )))";  TCut MuPlID = "((Reco_QQ_mupl_isGoodMuon==1) && Reco_QQ_mupl_nTrkWMea> 5 &&  Reco_QQ_mupl_nPixWMea > 0 && TMath::Abs(Reco_QQ_mupl_dxy) < 0.3 && TMath::Abs(Reco_QQ_mupl_dz) < 20 && Reco_QQ_VtxProb > 0.01 )";  TCut MuMiID = "((Reco_QQ_mumi_isGoodMuon==1) && Reco_QQ_mumi_nTrkWMea> 5 &&  Reco_QQ_mumi_nPixWMea > 0 && TMath::Abs(Reco_QQ_mumi_dxy) < 0.3 && TMath::Abs(Reco_QQ_mumi_dz) < 20 && Reco_QQ_VtxProb > 0.01 )";      unsigned int trigBit;  if (isHI)    trigBit=1; // DoubleMu0_HighQ  else    trigBit=1; // DoubleMu0_HighQ  TCut trigCut = Form("(HLTriggers&%u)==%u&&(Reco_QQ_trig&%u)==%u",trigBit,trigBit,trigBit,trigBit);  TString fname;  TString fnamepng;  TString outfname;  TString plotDir;    if(!is3D){plotDir = "Plots/2015";}  if(!is3D && significance){plotDir = "Plots/2015/significance";}  if(is3D){plotDir = "Plots/2015/3D";}  if(is3D && Binning){plotDir = "Plots/2015/3D/Binning";}  if(is3D && ctauFit){plotDir = "Plots/2015/3D/ctauFit";}  if(is3D && significance){plotDir = "Plots/2015/3D/significance";}    if (isHI) {    //    fname = "PbPb_eff_" + efficiency + "_Rap_" + ymin + "-" + ymax + "_Pt_" + ptmin + "-" + ptmax + ".pdf";    fname = Form("/Jpsi_PbPb_eff_%3.1f_Rap_%3.1f-%3.1f_Pt_%3.1f-%3.1f_Cent_%d-%d.pdf",efficiency,ymin,ymax,ptmin,ptmax,int(centmin/2.0),int(centmax/2.0));    fnamepng = Form("/Jpsi_PbPb_eff_%3.1f_Rap_%3.1f-%3.1f_Pt_%3.1f-%3.1f_Cent_%d-%d.png",efficiency,ymin,ymax,ptmin,ptmax,int(centmin/2.0),int(centmax/2.0));    outfname = Form("/Jpsi_PbPb_eff_%3.1f_Rap_%3.1f-%3.1f_Pt_%3.1f-%3.1f_Cent_%d-%d.root",efficiency,ymin,ymax,ptmin,ptmax,int(centmin/2.0),int(centmax/2.0));  }   else {    fname = Form("/Jpsi_pp_eff_%3.1f_Rap_%3.1f-%3.1f_Pt_%3.1f-%3.1f.pdf",efficiency,ymin,ymax,ptmin,ptmax);    fnamepng = Form("/Jpsi_pp_eff_%3.1f_Rap_%3.1f-%3.1f_Pt_%3.1f-%3.1f.png",efficiency,ymin,ymax,ptmin,ptmax);    outfname = Form("/Jpsi_pp_eff_%3.1f_Rap_%3.1f-%3.1f_Pt_%3.1f-%3.1f.root",efficiency,ymin,ymax,ptmin,ptmax);  }  std::cout << fname << std::endl;  std::cout << "default: " << defaultCut.GetTitle() << std::endl;  std::cout << "pt cut: " << ptCut.GetTitle() << std::endl;  std::cout << "rapidity cut: " << rapCut.GetTitle() << std::endl;  std::cout << "centrality cut: " << centCut.GetTitle() << std::endl;  std::cout << "trigger bit: " << trigCut.GetTitle() << std::endl;  TLatex *lpt;  if (ptmin==0.0)    lpt = new TLatex(0.38,0.82,Form("p_{T} < %3.1f GeV/c",ptmax));  else{    lpt = new TLatex(0.38,0.82,Form("%3.1f < p_{T} < %3.1f GeV/c",ptmin,ptmax));    lpt->SetTextSize(0.033);  }  TLatex *lrap;  if (absRapidity){    if (ymin==0.0){      lrap = new TLatex(0.38,0.77,Form("|y| < %3.1f",ymax));      lrap->SetTextSize(0.033);    }    else{      lrap = new TLatex(0.38,0.77,Form("%3.1f < |y| < %3.1f",ymin,ymax));      lrap->SetTextSize(0.033);    }  }  else {    if (ymin==0.0)      lrap = new TLatex(0.38,0.77,Form("y < %3.1f",ymax));    else      lrap = new TLatex(0.38,0.77,Form("%3.1f < y < %3.1f",ymin,ymax));  }  lpt->SetNDC(kTRUE);  lrap->SetNDC(kTRUE);    TLatex *lcent = NULL;  if (isHI) {    lcent = new TLatex(0.38,0.71,Form("Cent. %d-%d%%",int(centmin/2.0),int(centmax/2.0)));    lcent->SetTextSize(0.033);    lcent->SetNDC(kTRUE);  }    TChain *PRTree = NULL;  if (isHI) {    PRTree = new TChain("hionia/myTree");    PRTree->Add("/home/abdulla/CMS/quarkoniaData/Charm2015/rootfiles/MC/PbPb/Jpsi/OniaTree_Pythia8_JpsiMM_ptJpsi_00_03_Hydjet_MB_HINPbPbWinter16DR-75X_mcRun2_HeavyIon_v13-v1.root");    PRTree->Add("/home/abdulla/CMS/quarkoniaData/Charm2015/rootfiles/MC/PbPb/Jpsi/OniaTree_Pythia8_JpsiMM_ptJpsi_03_06_Hydjet_MB_HINPbPbWinter16DR-75X_mcRun2_HeavyIon_v13-v1.root");    PRTree->Add("/home/abdulla/CMS/quarkoniaData/Charm2015/rootfiles/MC/PbPb/Jpsi/OniaTree_Pythia8_JpsiMM_ptJpsi_06_09_Hydjet_MB_HINPbPbWinter16DR-75X_mcRun2_HeavyIon_v13-v1.root");    PRTree->Add("/home/abdulla/CMS/quarkoniaData/Charm2015/rootfiles/MC/PbPb/Jpsi/OniaTree_Pythia8_JpsiMM_ptJpsi_09_12_Hydjet_MB_HINPbPbWinter16DR-75X_mcRun2_HeavyIon_v13-v1.root");    PRTree->Add("/home/abdulla/CMS/quarkoniaData/Charm2015/rootfiles/MC/PbPb/Jpsi/OniaTree_Pythia8_JpsiMM_ptJpsi_12_15_Hydjet_MB_HINPbPbWinter16DR-75X_mcRun2_HeavyIon_v13-v1.root");    PRTree->Add("/home/abdulla/CMS/quarkoniaData/Charm2015/rootfiles/MC/PbPb/Jpsi/OniaTree_Pythia8_JpsiMM_ptJpsi_15_30_Hydjet_MB_HINPbPbWinter16DR-75X_mcRun2_HeavyIon_v13-v1.root");    PRTree->Add("/home/abdulla/CMS/quarkoniaData/Charm2015/rootfiles/MC/PbPb/Jpsi/OniaTree_Pythia8_JpsiMM_ptJpsi_30_Inf_Hydjet_MB_HINPbPbWinter16DR-75X_mcRun2_HeavyIon_v13-v1.root");  }  else{    PRTree = new TChain("hionia/myTree");    PRTree->Add("/home/abdulla/CMS/quarkoniaData/Charm2015/rootfiles/MC/pp/OniaTree_JpsiMM_5p02TeV_TuneCUETP8M1_HINppWinter16DR-75X_mcRun2_asymptotic_ppAt5TeV_v3-v1.root");  }    Float_t         muPlPt;  Float_t         muMiPt;  Float_t         muPlEta;  Float_t         muMiEta;  Float_t         QQctau3D;  Float_t         QQctau3DErr;    double invariantMass;  double JpsiPt;  double JpsiRap;  double vProb;  float muPlDxy;  float muPlDz;  int muPlNhits;  int muPlNPxlLayers;  int muPlNTrkLayers;  float muPlInnerChi;  float muPlGlobalChi;  int muPlNMuonhits;  bool muPlGoodMu;  bool muPlTrkArb;  bool muPlTMOneStaTight;  bool muPlHighPurity;  float muMiDxy;  float muMiDz;  int muMiNhits;  int muMiNPxlLayers;  int muMiNTrkLayers;  float muMiInnerChi;  float muMiGlobalChi;  int muMiNMuonhits;  bool muMiGoodMu;  bool muMiTrkArb;  bool muMiTMOneStaTight;  bool muMiHighPurity;  TH1F *hPR = new TH1F("hPR","hPR;l_{J/#psi} (mm);counts",1500,-5,10);  hPR->Sumw2();  hPR->SetLineColor(1);  TH1F* hPRCut = (TH1F*) hPR->Clone("hPRCut");    //double yBins[16] = {-5.0,-4.0,-3.0,-2.0,-1.0,0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0};  //double yBins[1501] = {0.0};  //for(int i=0;i<=1500;++i) {  //if(i==0) yBins[i] = -5.0 ; //[-5.0, 10.0]  //if(i!=0) yBins[i] = yBins[i-1] + (15/1500.);   //cout<<"yBins[i] "<<yBins[i]<<endl;  //}    //TH2D *hPR2D = new TH2D("hPR2D","hPR2D",nx,xBins,ny,yBins);  TH1D *projY[100];  TH1D *projYCut[100];  float lCuts[100] = {0.0}, pT[100] = {0.0};    int nx = 14, ny = 15000;  //double xBins[22] = {0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17.0,18.0,19.0,20.0,30.0}; //19  double xBins[15] = {3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,15.0,18.0,22.0,30.0}; //19  //double xBins[13] = {6.5,7.0,8.0,9.0,10.0,11.0,12.0,13.0,15.0,18.0,21.0,24.0,30.0}; //13  //double xBins[8] = {6.0,9.0,12.0,15.0,18.0,21.0,24.0,30.0}; //19  TH2D *hPR2D = new TH2D("hPR2D","hPR2D",nx,xBins,ny,-5.0,10.0);  for(int i=0; i<nx; i++) {    pT[i] = (xBins[i+1] + xBins[i])/2.0;  }  //pT[j-1] = j-1;    //TH2D *hPR2D = new TH2D("hPR2D","hPR2D;l_{J/#psi} (mm);counts",30,0.0,30.0,1500,-5,10);  //hPR2D->Sumw2();  //TH2D* hPR2DTemp = (TH2D*) hPR2D->Clone("hPR2DTemp");  initOniaTree(PRTree);  Long64_t nentries = PRTree->GetEntries();  //nentries = 50000;            cout<<"Total Entries in data  Tree  "<<"  "<<nentries<< "====="<<endl;  Long64_t nbytes = 0, nb = 0;   for (Long64_t jentry=0; jentry<nentries;jentry++) {    nb = PRTree->GetEntry(jentry);           for (int iQQ=0; iQQ<Reco_QQ_size; iQQ++) {      TLorentzVector *qq4mom = (TLorentzVector*) Reco_QQ_4mom->At(iQQ);      TLorentzVector *qq4mupl = (TLorentzVector*) Reco_QQ_mupl_4mom->At(iQQ);      TLorentzVector *qq4mumi = (TLorentzVector*) Reco_QQ_mumi_4mom->At(iQQ);            invariantMass = qq4mom->M();      JpsiPt = qq4mom->Pt();      JpsiRap = qq4mom->Rapidity();      muPlPt = qq4mupl->Pt();      muMiPt = qq4mumi->Pt();      muPlEta = qq4mupl->Eta();      muMiEta = qq4mumi->Eta();      QQctau3D = Reco_QQ_ctau3D[iQQ];      //QQctauTrue3D = Reco_QQ_ctauTrue3D[iQQ];      vProb = Reco_QQ_VtxProb[iQQ];      muPlDxy=Reco_QQ_mupl_dxy[iQQ];      muPlDz=Reco_QQ_mupl_dz[iQQ];      muPlNPxlLayers=Reco_QQ_mupl_nPixWMea[iQQ];      muPlNTrkLayers=Reco_QQ_mupl_nTrkWMea[iQQ];      muPlTMOneStaTight=Reco_QQ_mupl_TMOneStaTight[iQQ];      muPlGoodMu = Reco_QQ_mupl_isGoodMuon[iQQ];      muPlHighPurity = Reco_QQ_mupl_highPurity[iQQ];      muMiDxy=Reco_QQ_mumi_dxy[iQQ];      muMiDz=Reco_QQ_mumi_dz[iQQ];      muMiNPxlLayers=Reco_QQ_mumi_nPixWMea[iQQ];      muMiNTrkLayers=Reco_QQ_mumi_nTrkWMea[iQQ];      muMiTMOneStaTight=Reco_QQ_mumi_TMOneStaTight[iQQ];      muMiGoodMu = Reco_QQ_mumi_isGoodMuon[iQQ];      muMiHighPurity = Reco_QQ_mumi_highPurity[iQQ];      bool defaultpass =0, ptpass =0, rappass =0, PosPass=0, NegPass=0, AllCut=0 ,PosIn=0, NegIn=0,TriggerPass=0, centCut=0;            if(Reco_QQ_sign[iQQ]==0 && invariantMass>2.85 && invariantMass<3.25 && Reco_QQ_ctau3D[iQQ]>-500 && Reco_QQ_ctauTrue3D[iQQ]>-10) {defaultpass =1;}      if(!defaultpass) continue;            if(JpsiPt>ptmin && JpsiPt<ptmax)  {ptpass =1;}      if( fabs(JpsiRap)>ymin && fabs(JpsiRap) <ymax )   {rappass =1;}      if(Centrality>= centmin&& Centrality< centmax) {centCut =1;}      if(!ptpass) continue;      if(!rappass) continue;       if(!centCut) continue;             if( (HLTriggers&(ULong64_t)pow(2,0))==pow(2,0) && (Reco_QQ_trig[iQQ]&(ULong64_t)pow(2,0))==pow(2,0) )	{TriggerPass =1;}            if (fabs(muPlEta) < 2.4 && ( (fabs(muPlEta) < 1.2 && muPlPt >= 3.5 ) || (1.2 <= fabs(muPlEta) && fabs(muPlEta) < 2.1 && muPlPt >= 5.77-1.89*fabs(muPlEta )) || (2.1 <= fabs(muPlEta) && muPlPt >= 1.8 )) )  {PosIn =1;}	      if(fabs(muMiEta) < 2.4 && ( (fabs(muMiEta) < 1.2 && muMiPt >= 3.5 ) || (1.2 <= fabs(muMiEta) && fabs(muMiEta) < 2.1 && muMiPt >= 5.77-1.89*fabs(muMiEta )) || (2.1 <= fabs(muMiEta) && muMiPt >= 1.8 )) )  {NegIn =1;}      if( (muPlGoodMu==1) && muPlNTrkLayers> 5 &&  muPlNPxlLayers > 0 && TMath::Abs(muPlDxy) < 0.3 && TMath::Abs(muPlDz) < 20 && vProb > 0.01){PosPass=1;}      if( (muMiGoodMu==1) && muMiNTrkLayers> 5 &&  muMiNPxlLayers > 0 && TMath::Abs(muMiDxy) < 0.3 && TMath::Abs(muMiDz) < 20 ){NegPass=1;}      //if((Reco_QQ_mupl_isGoodMuon==1) && Reco_QQ_mupl_nTrkWMea> 5 &&  Reco_QQ_mupl_nPixWMea > 0 && TMath::fabs(Reco_QQ_mupl_dxy) < 0.3 && TMath::fabs(Reco_QQ_mupl_dz) < 20 && Reco_QQ_VtxProb > 0.01 )  {PosPass =1;}      //if((Reco_QQ_mumi_isGoodMuon==1) && Reco_QQ_mumi_nTrkWMea> 5 &&  Reco_QQ_mumi_nPixWMea > 0 && TMath::fabs(Reco_QQ_mumi_dxy) < 0.3 && TMath::fabs(Reco_QQ_mumi_dz) < 20 && Reco_QQ_VtxProb > 0.01 )  {NegPass =1;}            if(TriggerPass &&PosIn && NegIn && PosPass && NegPass) {AllCut = 1;}      if(!AllCut) continue;            hPR2D->Fill(JpsiPt,QQctau3D);    }  }  //*/  //PRTree->Draw("Reco_QQ_ctau3D>>hPR(1500,-5,10)",defaultCut&&ptCut&&rapCut&&trigCut&&IsPlAccept&&IsMiAccept&&MuPlID&&MuMiID,"e");  //PRTree->Draw("Reco_QQ_ctau3D:Reco_QQ_4mom.Pt()>>+hPR2D",defaultCut&&ptCut&&rapCut&&trigCut&&IsPlAccept&&IsMiAccept&&MuPlID&&MuMiID,"e1:e2");  //PRTree->Project("hPR2D","Reco_QQ_ctau3D&Reco_QQ_4mom.Pt()",defaultCut&&ptCut&&rapCut&&trigCut&&IsPlAccept&&IsMiAccept&&MuPlID&&MuMiID);    //PRTree->Draw("Reco_QQ_ctau3D:Reco_QQ_4mom.Pt()>>+hPR2D",defaultCut&&ptCut,"e1:e2");  //PRTree->Draw("Reco_QQ_4mom.Pt():Reco_QQ_ctau3D>>+hPR2D",defaultCut&&ptCut);  //hPR2D = (TH2D*)gPad->GetPrimitive("hPR2D");  //TH2D *hPR2D = (TH2D*)gDirectory->Get("hPR2D");   new TCanvas;  hPR2D->Draw("col");    cout<<hPR2D->GetNbinsX()<<endl;  cout<<hPR2D->GetNbinsY()<<endl;  for(int i=1;i<=hPR2D->GetNbinsX();++i) {    projY[i] = hPR2D->ProjectionY(Form("proY_%d",i),i,i);    projY[i]->Sumw2();    projYCut[i] = (TH1D*)projY[i]->Clone(Form("projYCut_%d",i));        if(i==6)cout<<" projY[i]X "<<projY[i]->GetNbinsX()<<endl;    if(i==6)cout<<" projY[i]Y "<<projY[i]->GetNbinsY()<<endl;        cout<<i<<" "<<"hPR2D Content "<<hPR2D->GetBinContent(i)<<endl;    //if(i<25)cout<<"hPR2D Xaxis Content "<<hPR2D->GetXaxis()->GetBinContent(i)<<endl;    new TCanvas;    projY[i]->SetFillColor(kBlue+1);    projY[i]->Draw("bar");  }    for(int j=1;j<=hPR2D->GetNbinsX();++j) {    for(int i=1;i<=projY[j]->GetNbinsX();++i) {      projYCut[j]->SetBinContent(i,projY[j]->Integral(1,i)/projY[j]->Integral(1,projY[j]->GetNbinsX()+1));      projYCut[j]->SetBinError(i,0.0);    }  }    bool stillLooking = true;  for(int j=1;j<=hPR2D->GetNbinsX();++j) {    stillLooking = true;    for (int i=1;i<=projYCut[j]->GetNbinsX();++i) {      if (projYCut[j]->GetBinContent(i)>efficiency && stillLooking) {	stillLooking = false;	cout<<" projYCut[j]Content "<<projYCut[j]->GetEntries()<<endl;	lCuts[j-1] = projYCut[j]->GetBinLowEdge(i);	//lCuts[j-1] = projYCut[j]->GetBinCenter(i);	cout<<setprecision(4);	std::cout << "Prompt J/psi efficiency of jth "<<j<<" "<<i<<": "<<  efficiency << " at l_Jpsi = " << lCuts[j-1] << std::endl;	//break;      }    }  }    TH1D *projX = hPR2D->ProjectionX();  // Drawing  new TCanvas;  projX->SetFillColor(kBlue-2);  projX->Draw("hbar");  TCanvas *Fitcanvas = new TCanvas("c","c",750, 550);  TGraph *ctauFW_pT = new TGraph(nx,pT,lCuts);  ctauFW_pT->SetLineColor(2);      ctauFW_pT->SetLineWidth(3);   ctauFW_pT->SetMarkerSize(1.35);  ctauFW_pT->SetMarkerStyle(20);  ctauFW_pT->SetMarkerColor(kGreen+3);  ctauFW_pT->GetYaxis()->SetTitle("l_{J/#psi}");  ctauFW_pT->GetXaxis()->SetTitle("p_{T}");    //TF1 *FitFn = new TF1("FitFn",ExpPol2,0.0,30.0,3);  //FitFn->SetParameters(2,-0.05);  //FitFn->SetParNames("C","a","b");  //FitFn->SetParNames("C","a","C1","a1","b1");  TF1 *FitFn = new TF1("FitFn",abpT,0.0,30.0,2);  FitFn->SetParNames("a","b");  FitFn->SetLineWidth(2.0);  FitFn->SetLineColor(2);  ctauFW_pT->Fit("FitFn","", "",3.0,30.0);  FitFn->Print("all");  gStyle->SetOptStat();  gStyle->SetFitFormat("1.4f");  TAxis *XaxctauFW = ctauFW_pT->GetXaxis();  XaxctauFW->SetLimits(0.0,30.0);  TAxis *YaxctauFW = ctauFW_pT->GetYaxis();  YaxctauFW->SetLimits(0.0,0.1);  ctauFW_pT->GetXaxis()->SetRangeUser(0.0,30.0);  ctauFW_pT->GetYaxis()->SetRangeUser(0.0,0.1);  ctauFW_pT->Draw("AP");   lpt->Draw();  lrap->Draw();  leg->Draw();    if (isHI)    lcent->Draw();  //Fitcanvas->Modified();   Fitcanvas->Update();  //Fitcanvas->BuildLegend(0.15, 0.7, 0.4, 0.9,"Ar-CO2-->70%-30%");  TPaveStats *st = ((TPaveStats*)(ctauFW_pT->GetListOfFunctions()->FindObject("stats")));  if(st) {    st->SetTextColor(1);    st->SetX1NDC(0.64); st->SetX2NDC(0.9);    st->SetY1NDC(0.687); st->SetY2NDC(0.90);  }    TList *list = st->GetListOfLines();  // Remove the RMS line  TText *tconst = st->GetLineWith("a");  TText *tconst1 = st->GetLineWith("c");  list->Remove(tconst); list->Remove(tconst1);    double chi2 = FitFn->GetChisquare();  double ndf = FitFn->GetNDF();  double a  = FitFn->GetParameter(0);  double aE = FitFn->GetParError(0);    double c = FitFn->GetParameter(1);  double cE = FitFn->GetParError(1);  //double  = FitFn->GetParameter(2);  //double  = FitFn->GetParError(2);    ///sprintf(params,"Mean_{J/#psi} = %0.1f #pm %0.2f GeV/c^{2}",ws->var("meanJPsi")->getVal(),ws->var("meanJPsi"                                                                                                         //t->DrawLatex(0.616,0.67,params);     char par0[400];    TLatex *myt = NULL; //new TLatex(0.0,0.0,Form("c ",c));  cout<<setprecision(4);  sprintf(par0,"c = %0.1f #pm %0.1f", FitFn->GetParameter(0), FitFn->GetParError(0));  myt = new TLatex(0.0,0.0,par0);  myt ->SetTextFont(42);  myt ->SetTextSize(0.04);  //myt ->SetTextColor(kRed);  list->Add(myt);  TLatex *myt1 = NULL; //new TLatex(0.0,0.0,Form("c ",c));  sprintf(par0,"a = %0.1f #pm %0.1f", FitFn->GetParameter(1), FitFn->GetParError(1));  myt1 = new TLatex(0.0,0.0,par0);  myt1 ->SetTextFont(42);  myt1 ->SetTextSize(0.04);  //myt1 ->SetTextColor(kRed);  list->Add(myt1);    TLatex *myt2 = new TLatex(0,0,"a+b/p_{T}");  myt2->SetTextFont(42);  myt2->SetTextSize(0.04);  myt2->SetTextColor(kRed);  list->Add(myt2);  //st->Draw();  Fitcanvas->Modified();      if (savePlot) {    Fitcanvas->SaveAs(plotDir+fname);    Fitcanvas->SaveAs(plotDir+fnamepng);    TFile *outf = new TFile(plotDir+outfname,"RECREATE");    hPR2D->Write();    ctauFW_pT->Write();    FitFn->Write();    outf->Close();        //outfname = "Jpsi_ctaueff.root";      }    return;}